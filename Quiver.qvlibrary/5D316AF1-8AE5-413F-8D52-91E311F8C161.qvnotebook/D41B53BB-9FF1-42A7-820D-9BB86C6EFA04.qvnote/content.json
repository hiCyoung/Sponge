{
  "title": "mysql乐观锁总结和实践",
  "cells": [
    {
      "type": "markdown",
      "data": "悲观锁并不是适用于任何场景，它也有它存在的一些不足，因为悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响了程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是对长事务而言，这样的开销往往无法承受。所以与悲观锁相对的，我们有了乐观锁，具体参见下面介绍：\n\n**乐观锁介绍：**\n\n乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。那么我们如何实现乐观锁呢，一般来说有以下2种方式：\n\n1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。用下面的一张图来说明：![](file:///var/folders/dv/2s1r72pn4k1fnl7wc9gsl0s80000gn/T/cn.wiz.wiznoteformac/WizNote/6b5ceaa7-6afa-46e8-b0e6-1f659390353f/index_files/2a1d8546-1e5d-4f6f-bbca-a4d3ba80516f.jpg \"点击查看原始大小图片\")\n\n如上图所示，如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修改，那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。\n\n2.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。\n\n**使用举例**：以MySQL InnoDB为例\n\n还是拿之前的实例来举：商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。\n\n下单操作包括3步骤：\n\n1.查询出商品信息\n\nselect (status,status,version) from t\\_goods where id=\\#{id}\n\n2.根据商品信息生成订单\n\n3.修改商品status为2\n\nupdate t\\_goods \n\nset status=2,version=version+1\n\nwhere id=\\#{id} and version=\\#{version};\n\n那么为了使用乐观锁，我们首先修改t\\_goods表，增加一个version字段，数据默认version值为1。\n\nt\\_goods表初始数据如下：\n\nSql代码  [![收藏代码](file:///var/folders/dv/2s1r72pn4k1fnl7wc9gsl0s80000gn/T/cn.wiz.wiznoteformac/WizNote/6b5ceaa7-6afa-46e8-b0e6-1f659390353f/index_files/a739645a-fe2f-49fc-a9bf-424f1af69ff4.png)](file:///Applications/WizNote.app/Contents/Resources/files/editor/index.html \"收藏这段代码\")\n\n1. mysql\\> select \\* from t\\_goods;\n2. +----+--------+------+---------+\n3. | id | status | name | version |\n4. +----+--------+------+---------+\n5. | 1 | 1 | 道具 | 1 |\n6. | 2 | 2 | 装备 | 2 |\n7. +----+--------+------+---------+\n8. 2 rows in set\n9. \n10. mysql\\>\n\n对于乐观锁的实现，我使用MyBatis来进行实践，具体如下：\n\nGoods实体类：\n\n```JAVA\n/**\n * ClassName: Goods <br/>\n * Function: 商品实体. <br/>\n * date: 2013-5-8 上午09:16:19 <br/>\n * @author chenzhou1025@126.com\n */\npublic class Goods implements Serializable {\n\n\t/**\n\t * serialVersionUID:序列化ID.\n\t */\n\tprivate static final long serialVersionUID = 6803791908148880587L;\n\t\n\t/**\n\t * id:主键id.\n\t */\n\tprivate int id;\n\t\n\t/**\n\t * status:商品状态：1未下单、2已下单.\n\t */\n\tprivate int status;\n\t\n\t/**\n\t * name:商品名称.\n\t */\n\tprivate String name;\n\t\n\t/**\n\t * version:商品数据版本号.\n\t */\n\tprivate int version;\n\t\n\t@Override\n\tpublic String toString(){\n\t\treturn \"good id:\"+id+\",goods status:\"+status+\",goods name:\"+name+\",goods version:\"+version;\n\t}\n\n\t//setter and getter\n\n}\n```\n\nGoodsDao\n```JAVA\n/**\n * updateGoodsUseCAS:使用CAS(Compare and set)更新商品信息. <br/>\n *\n * @author chenzhou1025@126.com\n * @param goods 商品对象\n * @return 影响的行数\n */\nint updateGoodsUseCAS(Goods goods);\n```\n\nmapper.xml\n\n```XML\n<update id=\"updateGoodsUseCAS\" parameterType=\"Goods\">\n\t<![CDATA[\n\t\tupdate t_goods\n\t\tset status=#{status},name=#{name},version=version+1\n\t\twhere id=#{id} and version=#{version}\n\t]]>\n</update>\n```\nGoodsDaoTest测试类\n\n```JAVA\n@Test\npublic void goodsDaoTest(){\n\tint goodsId = 1;\n\t//根据相同的id查询出商品信息，赋给2个对象\n\tGoods goods1 = this.goodsDao.getGoodsById(goodsId);\n\tGoods goods2 = this.goodsDao.getGoodsById(goodsId);\n\t\n\t//打印当前商品信息\n\tSystem.out.println(goods1);\n\tSystem.out.println(goods2);\n\t\n\t//更新商品信息1\n\tgoods1.setStatus(2);//修改status为2\n\tint updateResult1 = this.goodsDao.updateGoodsUseCAS(goods1);\n\tSystem.out.println(\"修改商品信息1\"+(updateResult1==1?\"成功\":\"失败\"));\n\t\n\t//更新商品信息2\n\tgoods1.setStatus(2);//修改status为2\n\tint updateResult2 = this.goodsDao.updateGoodsUseCAS(goods1);\n\tSystem.out.println(\"修改商品信息2\"+(updateResult2==1?\"成功\":\"失败\"));\n}\n```\n\n输出结果：\n\n1. good id:1,goods status:1,goods name:道具,goods version:1\n2. good id:1,goods status:1,goods name:道具,goods version:1\n3. 修改商品信息1成功\n4. 修改商品信息2失败\n\n说明：\n\n在GoodsDaoTest测试方法中，我们同时查出同一个版本的数据，赋给不同的goods对象，然后先修改good1对象然后执行更新操作，执行成功。然后我们修改goods2，执行更新操作时提示操作失败。此时t\\_goods表中数据如下：\n\n1. mysql\\> select \\* from t\\_goods;\n2. +----+--------+------+---------+\n3. | id | status | name | version |\n4. +----+--------+------+---------+\n5. | 1 | 2 | 道具 | 2 |\n6. | 2 | 2 | 装备 | 2 |\n7. +----+--------+------+---------+\n8. 2 rows in set\n\n\n我们可以看到 id为1的数据version已经在第一次更新时修改为2了。所以我们更新good2时update where条件已经不匹配了，所以更新不会成功，具体sql如下：\n```SQL\nupdate t_goods \nset status=2,version=version+1\nwhere id=#{id} and version=#{version};\n```\n\n这样我们就实现了乐观锁\n\n以上就是我对MySQL乐观锁的总结和实践，写得比较浅显，有不对的地方欢迎拍砖"
    }
  ]
}
{
  "title": "MapReduce执行过程简要总结",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">宏观上MapReduce可以分为以下三个阶段,如下图1所示。<br style=\"margin: 0px; padding: 0px;\">阶段1：input/map/partition/sort/spill<br style=\"margin: 0px; padding: 0px;\">阶段2：mapper端merge<br style=\"margin: 0px; padding: 0px;\">阶段3：reducer端merge/reduce/output</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><img src=\"quiver-image-url/D2D68822D2FCDE22474002155D1D0191.png\" alt=\"\" style=\"margin: 0px auto; padding: 0px; border: 0px; max-width: 720px; display: block;\"></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); text-align: center;\">图1 MapReduce执行过程</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">以下分别对上述三个阶段详解。首先是Mapper端的执行逻辑，主要包含以下三点，如图2所示：<br style=\"margin: 0px; padding: 0px;\">1. 将key/value/Partition写入到内存缓冲区中<br style=\"margin: 0px; padding: 0px;\">2. 当缓冲区使用量达到一定阀值，将其spill到disk上，spill前，需要进行排序<br style=\"margin: 0px; padding: 0px;\">3. 排序时先按照Partition进行排序，再按照key进行排序，默认排序算法是快速排序。<br style=\"margin: 0px; padding: 0px;\">注意： 在内存中进行排序时，数据本身不用移动，仅对索引排序即可</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><img src=\"quiver-image-url/692A103AD890D1F628E1D3FEE4681546.png\" alt=\"\" style=\"margin: 0px auto; padding: 0px; border: 0px; max-width: 720px; display: block;\"></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); text-align: center;\">图2 Mapper端逻辑</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">接下来是Map端的归并实现，主要包含以下两点，如图3所示。<br style=\"margin: 0px; padding: 0px;\">1.对生成的多个spill文件，进行归并排序<br style=\"margin: 0px; padding: 0px;\">2.最终归并成一个大文件<br style=\"margin: 0px; padding: 0px;\">注意：<br style=\"margin: 0px; padding: 0px;\">1. 由于每一个spill文件都是按分区和key排序好的，所以归并完的文件也是按分区和key排序好的。<br style=\"margin: 0px; padding: 0px;\">2.在进行归并的时候，不是一次性的把所有的spill文件归并成一个大文件。而是部分spill文件归并成中间文件，然后中间文件和剩下的spill文件再进行归并。</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"quiver-image-url/06333CFB52B520CCDD3292844BE813AC.png\" alt=\"\" style=\"margin: 0px; padding: 0px; border: 0px; max-width: 720px;\"><br style=\"margin: 0px; padding: 0px;\">图3 Map端Merge</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">最后是Reducer端的Merge和Reduce，主要包含以下三点，如图4所示：<br style=\"margin: 0px; padding: 0px;\">1. 当有新的MapTask事件完成时，拷贝线程从指定的机器上面拷贝数据<br style=\"margin: 0px; padding: 0px;\">2. 当数据拷贝的时候，分两种情况，当数据量小的时候就会写入内存当中，当数据量大的时候就会写入硬盘当中<br style=\"margin: 0px; padding: 0px;\">3. 来自不同的机器的多个数据文件，需要归并成一个文件.在拷贝文件过程中会进行文件归并操作.</p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); text-align: center;\"><img src=\"quiver-image-url/CEEE2C897689725F9872FCEB5E027C23.png\" alt=\"\" style=\"margin: 0px; padding: 0px; border: 0px; max-width: 720px;\"></p><p style=\"margin: 10px auto; padding: 0px; color: rgb(0, 0, 0); font-family: verdana, 'ms song', 宋体, Arial, 微软雅黑, Helvetica, sans-serif; font-size: 12px; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255); text-align: center;\">图4 Reducer端Merge和Reduce</p>"
    }
  ]
}
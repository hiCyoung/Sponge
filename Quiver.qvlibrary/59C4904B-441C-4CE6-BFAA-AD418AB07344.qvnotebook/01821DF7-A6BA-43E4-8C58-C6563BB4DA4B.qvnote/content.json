{
  "title": "如何有效保护脆弱的下游接口",
  "cells": [
    {
      "type": "markdown",
      "data": "### 前言\n\nMTS系统于去年十月正式上线，作为医疗服务平台，我们对外提供了一套完整的挂号、缴费等医疗在线服务交易接口，接入了多家医疗机构。上线至今，MTS累计服务人次超千万。我们致力于改善医疗环境，为患者提供良好的就医体验。\n<img src=\"quiver-image-url/B1E651950A613E64F7EA4EEF8AF31E24.jpg\" width=\"500\" height=\"150\" align=\"center\" alt=\"MTS\">\n\n但由于接入的友商系统（以下简称HIS）代码质量参差不齐、硬件资源受限等各种原因，接口经常不稳定，显得十分“脆弱”。为了能给用户提供良好的在线医疗服务，在保障MTS系统稳定的前提下，我们还得想办法“保护”好我们的下游系统。在此过程中，我们面临过不少的问题，选取其中两个比较突出的问题抛砖引玉，欢迎更多同学一起探讨，共同进步。\n\n### 面临问题\n\n#### 业务高峰下游系统接口不稳定\n挂号业务有明显的时间热点，有的医院下午三点放号，有的晚上十点放号，这样集中放号必然会出现某个时间点MTS会对HIS频繁请求，更新号源、号源锁定、支付通知等，这个时候HIS接口很容易出现响应慢、超时或系统错误。（监控发现，很多HIS系统并发数一旦超过2就会出现各种各样的问题），最终现象就是医院号挂不出去，患者挂不到号。\n\n#### 下游系统业务接口不幂等\n由于MTS的整个交易过程都是消息驱动，业务系统通过监听消息的变化来触发相应逻辑的执行，所以在某些场景下会存在同一个订单对HIS同一个接口并发调用的情况（此处暂不讨论为什么MTS无法避免重复请求），HIS会接收到两个请求，在处理第二个请求时往往会报错，返回“已取号”，“duplicate key ...”之类错误。也就是说针对MTS的重复请求，HIS没有相关的幂等逻辑，最终导致患者支付了却取不出号。通常来说，幂等是分布式系统接口设计里面必须要考虑的问题，作为被调用方，做好接口幂等是保证数据一致性的必要条件。\n\n发现问题的第一步我们肯定是向接入方反馈，督促保证接口的稳定和高可用。文档里我们虽然也明确要求某些接口HIS必须实现幂等，但由于接入方业务复杂，通常被以接口改造难度大为由婉拒，虽然有个别积极配合调整，但仍然效果欠佳。\n\n### 总体思路\n\n#### 限流\n\n针对第一个问题，首先想到的肯定是对HIS接口请求进行流量削峰，将瞬间高并发请求进行排队限速，均摊到一段时间范围内去请求。常见的限流算法有这两个：\n\n* `漏桶算法`：匀速处理请求，每秒总请求量是固定的。\n\n  <img src=\"quiver-image-url/6C7E847071C12AFA32D40DD9F1D2C586.png\" width=\"400\" height=\"250\" align=\"center\" alt=\"MTS\">\n\n* `令牌模式`：允许请求突发，但时间段内总量是固定，所以请求可能会出现”尖峰“。\n\n  ![token\\\\\\_bucket.JPG](quiver-image-url/1E4E88E1919464609121E476A96B83B3.jpg)\n\n目前Guava提供的工具类`RateLimiter`都已实现。\n\n#### 幂等\n\n针对第二个问题，HIS既然无法保证接口的幂等性，我们就得控制MTS对HIS的重复请求，并且做到看起来对HIS的调用结果返回是幂等的。处理的思路就是：每次请求HIS之后保存结果数据，请求之前判断是否已经请求过，同时还要解决同一个操作并发请求的case（其实这里就相当于做一个分布式锁的问题），并且要尽量少的改动现有的业务代码。\n\n![幂等.png](quiver-image-url/F5F308BAC77FD7363C98D2D9F790C271.jpg)\n\n### 解决方案\n\n#### 限流\n\n仔细分析，上面所提到的两种限流算法都不适合我们的场景。我们不能单纯以控制并发数和QPS来限流，而是要控制了“HIS正在处理的请求数”才能保证HIS的系统“有条不紊”地处理。所以我们需要一个计数器来就记录HIS正在处理的请求，请求之前、请求结束都需更新计数器。\n\n  <img src=\"quiver-image-url/9A3E81D3FEF6D2A2FF54C2D41FBDEB01.jpg\" width=\"500\", height=\"250\" align=\"center\">\n\n``` JAVA\ninterface AccessLimiter {\n  void acquire(...);\n  void release(...);\n}\n\n```\n\n``` Java\nclass HISAccessLimiter implements AccessLimiter {\n  // 每个医院对应一个信号量\n  private ConcurrentMap<String, Semaphore> limiters = Maps.newConcurrentMap();\n\n  @PostConstruct\n  void initLimit() {\n      // 初始化每个医院的计数器\n      limiters.putIfAbsent(hosCode, new Semaphore(calLimiter(hosCode)));\n      ...\n  }\n\n  void acquire(String hosCode, Consumer<> bizAction) {\n    if (limiters.get(hosCode).tryAcuire()) {\n      try {\n        bizAction.accept(()->{});\n      } catch(Exception e) {\n        //biz exception  \n      } finally {\n        release();\n      }\n    } else {\n      reject();\n    }\n  }\n\n  void release(String hosCode) {\n    getOrInitLimiter(hosCode).get(hosCode).release();\n  }\n\n  void reject(String hosCode, Consumer<> bizAction) {\n    throw new RejectException(\"系统繁忙，稍后再试\");\n  }\n}\n\n```\n\n当HIS在正在处理的请求数超过阈值时，直接抛出`RejectException`，让上层处理。这个基本上控制了“HIS正在处理的请求数”，但对被拦住请求的处理显得有点简单粗暴。通常来说，配合loading界面、后端对用户发出的请求自动重试让患者等待一个合理的时间比直接看到“挂号失败”要友好些。于是我们思考能否加入等待队列，设置合理的队列长度，设置重试请求的等待时间，超出队列大小rejecet，请求过期也直接丢弃。\n\n``` JAVA\nclass HISAccessLimiter implements AccessLimiter {\n  // 每个医院对应一个计数器\n  private ConcurrentMap<String, Semaphore> limiters = Maps.newConcurrentMap();\n  // 每个医院等待队列长度\n  private ConcurrentMap<String, AtomicLong> inQueueCounter = Maps.newConcurrentMap();\n  // 每个医院请求队列大小\n  private static final int MAX_QUEUE_SIZE = 10;\n  // 队列请求的间隔时间，这个取决于his接口的响应时间\n  private static final int ACQUIRE_INTERVAL = 100\n\n  @PostConstruct\n  void initLimit() {\n      // 初始化每个医院的计数器\n      limiters.putIfAbsent(hosCode, new Semaphore(calLimiter(hosCode)));\n      ...\n      // 初始化队列大小\n      inQueueCounter.putIfAbsent(hosCode, new AtomicLong(0L));\n      ...\n  }\n\n  void acquire(long expirePoint, String hosCode, Consumer<> bizAction) {\n    // 请求已过期\n    if (System.currentTimeMillis() > expire) {\n        throw new RejectException(\"系统繁忙，稍后再试\");\n    }\n    if (inQueueCounter(hosCode).get() >= MAX_QUEUE_SIZE) {\n      throw new RejectException(\"系统繁忙，稍后再试\");\n    }\n    if (limiters.get(hosCode).tryAcuire()) {\n      try {\n        bizAction.accept(()->{});\n      } catch(Exception e) {\n        //biz exception  \n      } finally {\n        release();\n      }\n    } else {\n      reject();\n    }\n  }\n\n  void release(String hosCode) {\n    inQueueCounter.get(hosCode).release();\n  }\n\n  void reject(String hosCode, Consumer<> bizAction) {\n    // 检查队列长度\n    if (inQueueCounter.get(hosCode).incrementAndGet() > MAX_QUEUE_SIZE) {\n      inQueueCounter.get(hosCode).decrementAndGet();\n      throw new RejectException(\"系统繁忙，稍后再试\");\n    }\n    // 加入重试队列\n    AccessScheduler.setTimeout(() -> {\n          inQueueCounter.get(hosCode).decrementAndGet();\n          acquire(expire, hosCode, true, reject, acquired);\n    }, ACQUIRE_INTERVAL, TimeUnit.MILLISECONDS, MoreExecutors.directExecutor());\n  }\n}\n\n```\n\n``` Java\nclass AccessScheduler {\n    ...\n    void setTimeout(final Runnable function, long time, TimeUnit timeUnit, final Executor executor) {\n        timer.schedule(() -> executor.execute(function), time, timeUnit);\n    }\n}\n\n```\n\n`AccessScheduler`用于调度队列中等待重试的请求，采用抢占式的非公平调度。\n至此，我们基本上实现了在不破坏用户体验的情况下严格控制“HIS正常处理的请求”的数量。上线之后效果明显，以往放号期间会出现很多由于HIS接口响应失败而导致取消的case都没有了。\n\n#### 幂等\n\n整体上来说，解决这个幂等问题需要做这几件事情：\n\n1. 调用HIS接口前先判断是否已请求过\n2. 控制同一个订单对同一个接口的并发请求\n3. 存储成功的响应\n考虑到对HIS的多个接口可能都需做幂等，为了方便使用和代码复用，同时还要尽量少地去改动业务逻辑代码，于是我们使用`Annotation` `AOP`的形式来做`Idempotent`。核心代码如下：\n\n``` JAVA\nclass HISInvoker {\n\n  @Idempotent\n  StandardResp<> takeTicket(StandardReq<> req) {...}\n\n  @Idempotent\n  StandardResp<> notifyPaid(StandardReq<> req) {...}\n}\n\n```\n\n``` JAVA\nclass HISIdempotentAop {\n\n  public Object doIdempotent(ProceedingJoinPoint jp) throws Throwable {\n        ...\n        Idempotent idempotent = methodSign.getMethod().getAnnotation(Idempotent.class);\n        if (idempotent == null) {\n            return jp.proceed();\n        } \n        ...\n        String reqKey = genIdempotentKey(methodSign);\n        StandardResp resp = getCached(storeKey);\n        // 命中缓存\n        if (resp != null) {\n            return resp;\n        }\n        // 未命中，需要请求his，需要考虑并发\n        String reqKey = genReqLockKey(methodSign);\n        if (!tryAcquireLock(reqKey)) {\n            throw new RuntimeException(\"并发冲突啦,稍后重试!\");\n        }\n        // 执行对his的调用\n        StandardResponse resp = joinPoint.proceed();\n        // 只存储HIS正确的响应\n        if (resp != null && result.isOK()) {\n          cacheResp(storeKey, result, idempotent.expire());\n        }\n        return proceed;\n    }\n\n    // 如果redis异常了要服务降级\n    boolean tryAcquireLock(String lockId) {\n        try {\n            Boolean lock = (Boolean)redisClient.setnx(lockId, \"1\");\n            return local == null || lock;\n        } catch (Throwable e) {\n            return true;\n        }\n    }\n}\n\n```\n\n通过方法上的注解`Idempotent`来标识该方法需要做幂等，AOP拦截注解方法做幂等逻辑检查，之前的业务代码也无需改动。以上代码基本上达到了HIS接口调用的“自我幂等”效果（除了接口超时下游系统已经成功处理的场景）。但需要注意redis存储请求结果时key的生成（要能唯一标识出同一个请求），以及redis服务出现异常的情况。\n\n### 总结思考\n\n1. 始终坚信，依赖的外部接口永远是不可靠的！外部接口出现问题时，在督促对方改进的同时，也要思考自己有无优化可能。\n2. 限流方案目前是针对单机请求，可能会有同学说现在都是分布式部署了，考虑到现在服务都有负载均衡，可以简单的认为每台机器承担的流量是一样的，在设置单机限流阈值时简单除以机器数，所以问题不大。如果要想实现分布式的流控，可以借助redis等第三方工具。\n3. 幂等的并发控制是利用redis的setnx来实现，在redis主从同步有延迟且发生切换的时候就会有问题，考虑到redis的HA以及我们的场景允许服务降级，所以暂时忽略。\n\n推荐阅读：\n* [常用限流算法](http://xiaobaoqiu.github.io/blog/2015/07/02/ratelimiter/)\n* [redis分布式锁](https://redis.io/topics/distlock)\n* [分布式系统幂等性问题的分析与解决](http://tech.meituan.com/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html)"
    },
    {
      "type": "text",
      "data": ""
    }
  ]
}
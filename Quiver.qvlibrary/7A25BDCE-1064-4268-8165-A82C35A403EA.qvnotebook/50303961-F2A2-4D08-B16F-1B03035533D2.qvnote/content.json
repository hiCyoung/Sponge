{
  "title": "Java 类初始化",
  "cells": [
    {
      "type": "text",
      "data": "<p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">类初始化是类加载过程的最后一个阶段，到初始化阶段，才真正开始执行类中的 Java 程序代码。虚拟机规范严格规定了有且只有四种情况必须立即对类进行初始化：</p><ul style=\"box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; font-size: 12px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\"><li style=\"box-sizing: border-box; font-size: 14px;\">遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。</li><li style=\"box-sizing: border-box; font-size: 14px;\">使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。</li><li style=\"box-sizing: border-box; font-size: 14px;\">当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li><li style=\"box-sizing: border-box; font-size: 14px;\">当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。</li></ul><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">虚拟机规定只有这四种情况才会触发类的初始化，称为对一个类进行主动引用，除此之外所有引用类的方式都不会触发其初始化，称为被动引用。下面举一些例子来说明被动引用。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">通过子类引用父类中的静态字段，这时对子类的引用为被动引用，因此不会初始化子类，只会初始化父类：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">class Father{  \n    public static int m = 33;  \n    static{  \n        System.out.println(\"父类被初始化\");  \n    }  \n}  \n\nclass Child extends Father{  \n    static{  \n        System.out.println(\"子类被初始化\");  \n    }  \n}  \n\npublic class StaticTest{  \n    public static void main(String[] args){  \n        System.out.println(Child.m);  \n    }  \n}  </code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行后输出的结果如下：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">父类被初始化\n    33</code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">对于静态字段，只有直接定义这个字段的类才会被初始化，因此，通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">class Const{  \n    public static final String NAME = \"我是常量\";  \n    static{  \n        System.out.println(\"初始化Const类\");  \n    }  \n}  \n\npublic class FinalTest{  \n    public static void main(String[] args){  \n        System.out.println(Const.NAME);  \n    }  \n}  </code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行后输出的结果如下：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">我是常量</code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">虽然程序中引用了 const 类的常量 NAME，但是在编译阶段将此常量的值“我是常量”存储到了调用它的类 FinalTest 的常量池中，对常量 Const.NAME 的引用实际上转化为了 FinalTest 类对自身常量池的引用。也就是说，实际上 FinalTest 的 Class 文件之中并没有 Const 类的符号引用入口，这两个类在编译成 Class 文件后就不存在任何联系了。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">通过数组定义来引用类，不会触发类的初始化：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">class Const{  \n    static{  \n        System.out.println(\"初始化Const类\");  \n    }  \n}  \n\npublic class ArrayTest{  \n    public static void main(String[] args){  \n        Const[] con = new Const[5];  \n    }  \n}  </code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">执行后不输出任何信息，说明 Const 类并没有被初始化。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">但这段代码里触发了另一个名为“LLConst”的类的初始化，它是一个由虚拟机自动生成的、直接继承于java.lang.Object 的子类，创建动作由字节码指令 newarray 触发，很明显，这是一个对数组引用类型的初初始化，而该数组中的元素仅仅包含一个对 Const 类的引用，并没有对其进行初始化。如果我们加入对 con 数组中各个 Const 类元素的实例化代码，便会触发 Const 类的初始化，如下：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">class Const{  \n    static{  \n        System.out.println(\"初始化Const类\");  \n    }  \n}  \n\npublic class ArrayTest{  \n    public static void main(String[] args){  \n        Const[] con = new Const[5];  \n        for(Const a:con)  \n            a = new Const();  \n    }  \n}  </code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">这样便会得到如下输出结果：</p><pre style=\"box-sizing: border-box; overflow: auto; font-family: Menlo, Monaco, Consolas, 'Courier New', monospace; padding: 9.5px; margin-top: 0px; margin-bottom: 10px; line-height: 1.42857; word-break: break-all; word-wrap: break-word; background-color: rgb(245, 245, 245); border: 1px solid rgb(204, 204, 204); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; font-variant-ligatures: normal; orphans: 2; widows: 2;\"><code style=\"box-sizing: border-box; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 14px; color: rgb(45, 133, 202); border-top-left-radius: 0px; border-top-right-radius: 0px; border-bottom-right-radius: 0px; border-bottom-left-radius: 0px; white-space: pre-wrap;\">初始化Const类</code></pre><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">根据四条规则的第一条，这里的 new 触发了 Const 类。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">最后看一下接口的初始化过程与类初始化过程的不同。</p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">接口也有初始化过程，上面的代码中我们都是用静态语句块来输出初始化信息的，而在接口中不能使用“static{}”语句块，但编译器仍然会为接口生成<clinit style=\"box-sizing: border-box;\">类构造器，用于初始化接口中定义的成员变量（实际上是 static final 修饰的全局常量）。</clinit></p><p style=\"box-sizing: border-box; margin: 0px 0px 10px; font-size: 14px; color: rgb(102, 102, 102); line-height: 26px; font-family: Verdana, 'Lantinghei SC', 'Hiragino Sans GB', 'Microsoft Yahei', Helvetica, arial, 宋体, sans-serif; font-variant-ligatures: normal; orphans: 2; widows: 2; background-color: rgb(255, 255, 255);\">二者在初始化时最主要的区别是：当一个类在初始化时，要求其父类全部已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量），才会初始化该父接口。这点也与类初始化的情况很不同，回过头来看第 2 个例子就知道，调用类中的 static final 常量时并不会 触发该类的初始化，但是调用接口中的 static final 常量时便会触发该接口的初始化。</p>"
    }
  ]
}